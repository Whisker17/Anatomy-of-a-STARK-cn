# STARKs 详解，第 1 部分：STARKs 概述

STARKs 是一种交互式证明系统。 但为了更好的理解，你可以将它们视为 SNARKs 的特殊案例：

- 散列函数是唯一的密码学集成
- 算术化基于 AIR (代数中间表示[^1])，将关于计算完整性的声明简化为关于某多项式低阶的声明
- 使用 FRI 作为子协议可以证明多项式的低阶， 并且 FRI 本身用默克树实例化 [^2];
- 零知识是可选的。

本教程的这一部分是要解释 STARKs 定义中的关键术语。

## 交互式证明系统

在计算复杂性理论中，交互式证明系统是至少两个当事方之间的协议，其中一方为验证人，且只要而且只有在该声明是正确的情况下，验证人确信相应的数学声明是正确的。 从理论上讲，声明可以用数学符号，例如 Birch 和 Swinnerton-Dyer 的推测来表述。 $\mathbf{P} \neq \mathbf{NP}$, 或 "第十五个 Fibonacci 数字是 643617." (在一个健全的证明系统中，验证人将拒绝最后一个声明。)

一个密码学证明系统将这种交互式证明系统的抽象概念变成一个打算在现实世界中部署的具体目标。 这种对现实世界应用的限制促成了一些简化：

- 该声明并不涉及数学推测，而涉及某一特定计算的完整性。 如"电路 $C$ 在输入 $x$ 时结果输出 $y$ ", 或 "图灵机 $M$ 在 $T$ 步后输出 $y$ 那么我们就说该证明系统已建立 _计算完整性_。
- 协议中有两种角色，即证明人和验证人。 在不失去通用性的情况下，验证人向证明人发送的信息包含了纯粹的随机性。在这种情况下(所以：几乎总是)，证明系统可以与 _Fiat-Shamir转换_ 不交互。 非交互式证明系统中仅有一条从证明人到验证人的信息。
- 验证人不需要保证完美的安全性，而是可以接受非常小的错误率。 或者，证明系统针对其计算能力受限的证明人提供安全性保证也是可以接受的。 毕竟，所有计算机实际上都有计算界限。 有时作者使用术语 _参数系统_ 来区分协议和提供计算无界限安全性的的证明系统，以及_参数_，用于非交互性转换产生的文本。
- 必须有令人信服的理由说明为什么验证人不能单纯重新运行计算，因为计算完整性声明主张其完整性。 这是因为证明人能够获得验证人无法获得的信息。
  - 当时间受限时，验证人应该比原生系统的重新执行程序快一个数量级。 这样我们就称实现此属性的系统是 _简洁_ 或 _简洁验证_。
  - 简洁验证需要较短的证明，但是一些证明系统，例如 [Bulletproofs](https://eprint.iacr.org/2017/1066.pdf) or [Aurora](https://eprint.iacr.org/2018/828.pdf) 其有紧凑的证明，但仍然验证依然比较慢。
  - 当验证人无法获取证明人提供的秘密信息时， 并且当证明系统确保此秘密的保密性时，证明系统满足了 _零知识性_ 的要求。 验证人相信计算声明的真实性，但却不了解对计算的部分或全部输入。
- 特别是在零知识证明的背景中，计算完整性要求可能需要稍微有些调整。 在有些情况下，仅仅证明声明的正确性是不够的。 证明人还必须另外证明他 _知道_ 额外的秘密输入， 而且也可以不生成证明而直接输出秘密。[^3] 实现这种更强有力的可靠性概念，即知识健全性的证明系统被称为 _知识(或论点)证明_

SNARK是 _一个非交互式的知识论证_。 该 [论文](https://eprint.iacr.org/2011/443.pdf) 构造了 SNARK 一词，使用 _简洁_ 表示高效验证人的证明系统。 然而，近年来该词的含义被淡化，以包括任何紧凑证明的系统。 本教程将还原其原始定义。

## STARK 概述

“STARK”是一个缩写词，指可扩展透明知识论证。 _可扩展_ 是指以下两件事情同时发生：(1)证明人的运行时间在计算量上最多是准线性的， 与在 SNARK 中允许其非常大的复杂性形成对比，(2) 验证时间是计算量上是多对数级别的。 _透明_ 是指所有验证人消息都是公开的。 尤其是，不需要可信初始化来实例化证明系统，因此不存在密码学有害物。 缩写词表示非交互式 STARKs 是 SNARKs 的一个子类，但实际上该词一般用来指用于可扩展透明的 SNARKs 的 _特定的_ 构造。

这一构造的特殊性质在编译过程中得到最好的说明。 根据不同程度的粒度，人们可能会选择将这个过程分成更多或者更少步骤。 我们把编译过程分为四个阶段和三个转换以介绍 STARKs。 本教程稍后将有更详细的过程和图表。

![编译过程分为三个转换和四个阶段。](./../../graphics/pipeline.svg "SNARKs 编译过程概述")

### 计算

整个过程中的输入是 _计算_，您可以将其视为一个程序、一个输入或是另一段输出。 这三种方式都以机器友好的格式存在，例如字节列表。 一般而言，程序由决定机器如何操纵其资源的指示组成。 如果正确的指令列表可以模拟任意的图灵机，那么该机器便是图灵完备的。

在这个教程中，程序被硬编码到机器架构中。 因此，允许的计算空间相当有限。 尽管如此，输入和输出依然是可变的。

计算所需的 _资源_ 可能是 _时间_, _内存_ _随机性_, _秘密信息_ 和 _并行性_. 目标是将计算转变为一种格式，使资源有限的验证人能够验证其完整性。 仍然可以研究更多类型的资源，例如缠纠缠的量子比特、 非确定性的或计算特定的黑盒函数的预言机 。 但由此产生的问题通常是计算复杂性理论，而不是密码学实践问题。

### 算术和算术约束系统

过程中的第一个转换称为 _算术_。 在此过程中，在位串上的基本逻辑和算术运算序列被转换为对有限域元素的原生有限域操作序列，使得两者表示相同的计算。 输出是一个算术约束系统，本质上是一堆方程，其系数和变量从有限域中取值。 计算完备是指_当且仅当_约束系统有一个令人满意的解决方案——这意味着，有一个解使得所有方程都成立。

STARK 证明系统算术化进行了以下运算： 在任何时间点，计算状态都包含在 $\mathsf{w}$ 寄存器的元组中，这些寄存器从有限域 $\mathbb{F}$ 中获取值。 机器定义了一个_状态转换函数_ $f : \mathbb{F}^\mathsf{w} \rightarrow \mathbb{F}^\mathsf{w}$，每个周期更新状态。 _代数执行跟踪 (AET)_ 是按时间顺序排列的所有状态元组的列表。

算术约束系统在代数执行轨迹上定义了至少两种类型的约束：

- _边界约束_: 在计算开始或结束时，指定的寄存器有一个给定的值。
- _转换约束_：任意两个连续的状态元组按照状态转换函数演化。

这些约束统称为_代数中间表示_或_AIR_。 高级 STARKs 可以定义更多的约束类型，以便在一个周期内处理内存或寄存器的一致性。

### 插值和多项式 IOPs

通常意义上的插值意味着找到一个通过一组数据点的特定多项式。 在 STARK 编译过程中， _插值_ 意味着找到算术约束系统的多项式表示。 结果的对象不是一个算术约束系统，而是一个叫做 _多项式 IOP_ 的抽象协议。

常规证明系统中证明人向验证人发送信息。 但是，如果不允许验证人读取该信息，会发生什么情况？ 具体而言，如果证明人的信息被预言机所取代，则验证人可以在他所选择的点中查询抽象的黑盒函数，这便是是 _交互式预言机证明(IOP)_。 当预言机对应于低次多项式时，这便是 _多项式 IOP_。 直观的意思是，诚实的证明人获得多项式约束系统，其中方程组是成立的。 而作恶的证明人其多项式约束系统中使用至少存在一个错误的方程。 两个多项式相等时，它们在任何点都是相同的，特别是在验证人选择的随机点上。 但是当多项式不相等时，它们_几乎_处处不相等，并且当验证人在随机点中探测左右侧时，这种不相等很可能会暴露出来。

STARK 证明系统从字面上插入代数执行轨迹——也就是说，它找到了 $\mathsf{w}$ 多项式 $t_i(X)$ 使得值 $t_i(X)$ 具有域 $D$ 对应于第 $i$th 个寄存器的代数执行轨迹。 这些多项式作为预言机发送到验证人。 在这一点上，AIR（代数中间表示）的约束导致多项式运算，只有在符合约束的情况下才能将低次多项式发送到低次多项式。 验证人模拟这些操作，因此可以推导出新的多项式，其低幂次证明了约束系统的可满足性，从而证明了计算的完整性。 换言之，插值将算术约束系统的可满足性降低为关于某些多项式的低幂次的声明。

### 使用 FRI 的密码学编译

现实中，多项式预言机并不存在。 想要使用多项式 IOP 作为中间阶段的协议设计者必须找到一种方法来提交多项式，然后在验证人选择的点打开该多项式。 FRI 是 STARK 证明的关键组成部分，它通过使用 Reed-Solomon 码字的 Merkle 树来证明多项式次数的有界性，从而实现了这一任务。

与多项式 $f(X)\in\mathbb{F}[X]$ 相关的 Reed-Solomon 码字是它在给定域 $D\subset\mathbb{F}$ 上所取值的列表。 不考虑一般域$D$的损失，其基数大于多项式的最大允许次数。 这些值可以放入 Merkle 树中，在这种情况下，根代表对多项式的承诺。 _快速近似 Reed-Solomon IOP (FRI)_ 是一种协议，它的证明者发送一个 Merkle 根序列，该序列对应于在每次迭代中长度减半的码字。 验证人检查连续轮次的默克尔树（特别是：要求证明人提供指示的叶子节点及其认证路径）以测试简单的线性关系。 对于诚实的证明人而言，所表示的多项式的次数同样在每一轮中减半，因此远小于码字的长度。 然而对于恶意证明人来说，这个幂次数比码字的长度小一。 在最后一步中，证明人发送一个与常数多项式相对应的重要码字。

上面的描述没有捕捉到一个小问题：验证者如何在不属于域的点 $z$ 中查询提交的多项式 $f(X)$？ 原则上有一个明显而直接的解决方案：验证人向证明人发送 $z$，证明人通过发送 $y=f(z)$ 来响应。 多项式 $f(X) - y$ 在 $X=z$ 中为零，因此必须能被 $X-z$ 整除。 因此证明人和验证人都可以访问一个新的低次多项式 $\frac{f(X) - y}{X-z}$。 如果证明者在 $f(z)=y$ 上准备做恶，那么他就无法证明 $\frac{f(X) - y}{X-z}$ 的低幂次，因此他的做恶行为将会暴露在 FRI 协议的过程。 这实际上是强制边界约束的确切机制； 一个稍微复杂但类似的构造会强制转换约束。 新的多项式是除以已知因子的结果，因此它们将被称为_商_并表示为 $q_i(X)$。

至此，多项式 IOP 已编译为交互式具体证明系统。 原则上协议可以执行。 然而，多增加一个密码学编译步骤是值得的：用伪随机的东西替换验证人的随机数（即 _随机性_）——但这种操作是具有确定性的。  这正是 Fiat-Shamir 变换，其结果是称为 STARK 的非交互式证明。

![STARK 证明系统围绕着将低阶多项式转换为幂次有界与计算完整性相匹配的新多项式。](./../../graphics/stark-overview.svg "SNARKs 编译过程概述")

这样描述并没有披露许多细节。 本教程的其余部分将以更具体和有形的术语解释构造，并将在图中插入更具有细粒度的组件。

[0](index) - **1** - [2](basic-tools) - [3](fri) - [4](stark) - [5](rescue-prime) - [6](faster)

[^1]: 另外，代数 _内部_ 表示。
[^2]: 请注意，FRI 是根据可以在任意位置查询的抽象预言机定义的； 因此，可以通过使用任何密码学向量承诺方案模拟预言机，将 FRI 协议编译为具体协议。 Merkle 树提供了此功能，但不是唯一的密码学原语。
[^3]: 形式上，_知识的_ 定义如下：必须存在一个提取器算法，它可以访问可能做恶的证明人，伪装成匹配的验证者（特别是读取来自证明人的消息并通过相同的接口发送它自己的信息），有能力将可能做恶证明人倒回到任何更早的时间点，在多项式时间内运行，并输出见证。 STARKs 已被证明满足此属性，请参阅 [EthSTARK 文档](https://eprint.iacr.org/2021/582.pdf)的第 5 节。
